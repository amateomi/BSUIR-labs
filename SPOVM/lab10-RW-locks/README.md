# Тема: Блокировки чтения/записи

**Задание:**

Задача ‒ обеспечить конкурентный доступ к файлу по чтению/записи, используя
метод ISAM (Index Sequential Access Method ‒ метод индексного последовательного
доступа), со стороны нескольких процессов.

Файл имеет базовую структуру простого склада товаров. Этот файл, назовем его
TABLE, содержит заголовок и записи фиксированной длины. Каждая запись включает
минимально следующие поля:

|   Поле   | Ключ |                    Примечание                    |
|:--------:|:----:|:------------------------------------------------:|
|    ID    |  P   | Внутренний идентификатор товара (главный индекс) |
|   NAME   |  SM  |               Наименование товара                |
|   CODE   |  SU  |                    Код товара                    |
|  AMOUNT  |      |                Количество товара                 |
| RESERVED |      |                 Зарезервировано                  |

P ‒ первичный ключ, уникальное значение, автоинкремент при добавлении. <br>
SU ‒ вторичный ключ, уникальное значение. <br>
SM ‒ вторичный ключ, неуникальное значение.

С каждым из ключей связан индексный файл, содержащий записи фиксированной длины
с двумя полями, позволяющий по значению ключа получать прямой доступ к записи в
файле за один или два шага чтения. Структура индексных файлов:

| Индексный файл | Ключ |         Значение         |
|:--------------:|:----:|:------------------------:|
|  MASTER_INDEX  |  ID  | Порядковый номер записи  |
|   NAME_INDEX   | NAME |      Главный индекс      |
|   CODE_INDEX   | CODE |      Главный индекс      |

Индексный файл PROD_MASTER может быть упорядочен либо сортировкой, либо
хешированием, поскольку поддерживает только прямой доступ. Индексные файлы
NAME_INDEX и CODE_INDEX упорядочиваются сортировкой, поскольку помимо прямого
доступа должны поддерживать и последовательный.

База данных должна поддерживать ряд операций:

1. **ADD_RECORD ‒ добавить запись**

Запись добавляется в файл TABLE, а также в индексные файлы в порядке 
соответствующих ключей. Добавление выполняется как атомарная операция над всеми
измененными файлами.

Запись добавляется на место удаленной ранее записи, если такие есть, либо в
конец файла. Для добавления новой записи на место удаленной можно поддерживать
файл учета удалений с организацией в виде стека, в который помещаются порядковые
номера удаленных записей.

Заголовок файла содержит поле, которое используется для автоинкрементной 
генерации первичного ключа, и поле количества записей в файле, которые должны
атомарно изменяться при добавлении.

2. **DEL_RECORD ‒ удалить запись**

Запись удаляется из файла TABLE, а также из индексных файлов в порядке 
соответствующих ключей. Удаление выполняется как атомарная операция над всеми
измененными файлами.

Порядковый номер удаленной записи заносится в файл учета удалений.

Поле количества записей в заголовке файла изменяется.

3. **GET_RECORD ‒ получить запись по главному индексу**

Возвращает запись из файла TABLE, либо ошибку.

4. **PUT_RECORD ‒ изменить запись по главному индексу**

Записывает запись в TABLE на место полученное из MASTER_INDEX и перестраивает
все затронутые вторичные индексы. Главный индекс при этом не меняется и
соответствующий файл перестройки не требует.

5. **GET_PRIMARY ‒ получить главный индекс по имени или коду**

Возвращает главный индекс из соответствующего вторичного индекса, либо ошибку,
если нет такого значения в поле ключа.

**Замечания**

Индексные файлы кешируются и отображаются в памяти в виде контейнеров
std::map. При изменении индекса в кеше (вставка/удаление в контейнере)
соответствующий индексный файл приводится в согласованное с кешем состояние.
Для уведомления других процессов об изменении индексного файла можно
использовать fcntl(F_NOTIFY).
